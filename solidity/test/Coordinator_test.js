import {
  assertActionThrows,
  bigNum,
  calculateSAID,
  checkPublicABI,
  deploy,
  newAddress,
  newHash,
  oracleNode,
  personalSign,
  recoverPersonalSignature,
  stranger,
  toHex
} from './support/helpers';
import { assertBigNum } from './support/matchers'

contract('Coordinator', () => {
  const sourcePath = 'Coordinator.sol'
  let coordinator

  beforeEach(async () => {
    coordinator = await deploy(sourcePath)
  })

  it('has a limited public interface', () => {
    checkPublicABI(artifacts.require(sourcePath), [
      'getPackedArguments',
      'getId',
      'initiateServiceAgreement',
      'serviceAgreements'
    ])
  })

  const sixMonthsFromNow = Math.round(
    (Date.now() / 1000.) + (6 * 31 * 24 * 60 * 60))
  let endAtBinary = sixMonthsFromNow.toString(16)
  // XXX: How to import left-pad?? I've always wanted to touch fame by using it...
  if (endAtBinary.length < 8) {
    endAtBinary = '0'.repeat(8 - endAtBinary.length) + endAtBinary
  }

  const args = [1, 2, sixMonthsFromNow,
                ['0x70AEc4B9CFFA7b55C0711b82DD719049d615E21d',
                 '0xd26114cd6EE289AccF82350c8d8487fedB8A0C07'],
                '0x85820c5ec619a1f517ee6cfeff545ec0ca1a90206e1a38c47f016d4137e801dd'
               ]

  const expectedBinaryArgs = '0x0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000' +
        endAtBinary +
        '00000000000000000000000070aec4b9cffa7b55c0711b82dd719049d615e21d000000000000000000000000d26114cd6ee289accf82350c8d8487fedb8a0c0785820c5ec619a1f517ee6cfeff545ec0ca1a90206e1a38c47f016d4137e801dd'

  const expectedBinaryArgsSha3 = web3.sha3(expectedBinaryArgs, { encoding : 'hex' })

  describe('show arguments', () => {
    // This is mostly useful as a sanity check, because the hash value in the
    // next test is illegible by design... Uncomment the log commands to see
    // what's going on.
    it('returns the following value, given these arguments', async() => {
      let result = await coordinator.getPackedArguments.call(...args);
      // console.log(result)
      // console.log(expectedBinaryArgs)
      assert.equal(result, expectedBinaryArgs);
    })
  })

  describe('#getId', () => {
    it('matches the ID generated by the oracle off-chain', async () => {
      let result = await coordinator.getId.call(...args);
      console.log('shas', result, expectedBinaryArgsSha3)
      assert.equal(result, expectedBinaryArgsSha3)
    })
  })

  describe('#initiateServiceAgreement', () => {
    let payment, expiration, oracle, oracles, requestDigest,
      serviceAgreementID, oracleSignature

    beforeEach(() => {
      payment = newHash('1000000000000000000')
      expiration = newHash('300')
      oracle = newAddress(oracleNode)
      oracles = [oracle]
      requestDigest = newHash('0x9ebed6ae16d275059bf4de0e01482b0eca7ffc0ffcc1918db61e17ac0f7dedc8')

      serviceAgreementID = calculateSAID(payment, expiration, oracles, requestDigest)
    })

    context("with valid oracle signatures", () => {
      beforeEach(() => {
        oracleSignature = personalSign(oracle, serviceAgreementID)
        const requestDigestAddr = recoverPersonalSignature(serviceAgreementID, oracleSignature)
        assert.equal(toHex(oracle), toHex(requestDigestAddr))
      })

      it('saves a service agreement struct from the parameters', async () => {
        await coordinator.initiateServiceAgreement(
          toHex(payment),
          toHex(expiration),
          oracles.map(toHex),
          [oracleSignature.v],
          [oracleSignature.r].map(toHex),
          [oracleSignature.s].map(toHex),
          toHex(requestDigest)
        )

        const sa = await coordinator.serviceAgreements.call(toHex(serviceAgreementID))

        assertBigNum(sa[0], bigNum(toHex(payment)))
        assertBigNum(sa[1], bigNum(toHex(expiration)))
        assert.equal(sa[2], toHex(requestDigest))

        /// / TODO:
        /// / Web3.js doesn't support generating an artifact for arrays within a struct.
        /// / This means that we aren't returned the list of oracles and
        /// / can't assert on their values.
        /// /
        /// / However, we can pass them into the function to generate the ID
        /// / & solidity won't compile unless we pass the correct number and
        /// / type of params when initializing the ServiceAgreement struct,
        /// / so we have some indirect test coverage.
        /// /
        /// / https://github.com/ethereum/web3.js/issues/1241
        /// / assert.equal(
        /// /   sa[2],
        /// /   ['0x70AEc4B9CFFA7b55C0711b82DD719049d615E21d', '0xd26114cd6EE289AccF82350c8d8487fedB8A0C07']
        /// / )
      })
    })

    context("with an invalid oracle signatures", () => {
      beforeEach(() => {
        oracleSignature = personalSign(newAddress(stranger), serviceAgreementID)
        const requestDigestAddr = recoverPersonalSignature(serviceAgreementID, oracleSignature)
        assert.notEqual(toHex(oracle), toHex(requestDigestAddr))
      })

      it('saves a service agreement struct from the parameters', async () => {
        assertActionThrows(async () => {
          await coordinator.initiateServiceAgreement(
            toHex(payment),
            toHex(expiration),
            oracles.map(toHex),
            [oracleSignature.v],
            [oracleSignature.r].map(toHex),
            [oracleSignature.s].map(toHex),
            toHex(requestDigest)
          )
        })

        const sa = await coordinator.serviceAgreements.call(toHex(serviceAgreementID))
        assertBigNum(sa[0], bigNum(0))
        assertBigNum(sa[1], bigNum(0))
        assert.equal(sa[2], '0x0000000000000000000000000000000000000000000000000000000000000000')
      })
    })
  })
})
